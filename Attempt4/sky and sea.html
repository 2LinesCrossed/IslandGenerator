<!DOCTYPE html>
<html>
  <head>
    <meta charset=UTF-8 />
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script type="text/javascript" src="js/dat.gui.min.js"></script>
    <script>
    
    //create the scene
    var scene = new THREE.Scene();
    var ratio = window.innerWidth/window.innerHeight;
    var camera = new THREE.PerspectiveCamera(45,ratio,45,30000);
        camera.position.set(0,30,15);
        camera.lookAt(0,0,1);
    var renderer = new THREE.WebGLRenderer( );
        renderer.setSize(window.innerWidth,window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

    var sphere_mesh;
    var sphere;
    var cube;
      function CreateScene(){
        //test shadow
      var geometry = new THREE.BoxGeometry( 60, 4, 5 );
      var material = new THREE.MeshLambertMaterial( {color: 0x00ff00} );
      cube = new THREE.Mesh( geometry, material );
      cube.position.y -= 40;
      cube.castShadow = true;
      //cube.receiveShadow = false;
      scene.add( cube );

      // sky
       var geometrySky = new THREE.SphereGeometry( 10000, 32, 32 );
      var materialSky = new THREE.MeshLambertMaterial( {map: new THREE.TextureLoader().load('sky.png'), side: THREE.DoubleSide} );
      var sky = new THREE.Mesh( geometrySky, materialSky );
      scene.add( sky );

      //floor
      var geometryG = new THREE.PlaneGeometry( 10000, 10000, 32 );
      var materialG = new THREE.MeshLambertMaterial( {color: 0x8c3b0c, side: THREE.DoubleSide} );
      var ground = new THREE.Mesh( geometryG, materialG );
      ground.rotation.x = THREE.Math.degToRad(-90);
     ground.position.y -= 100;
      ground.receiveShadow = true;
      scene.add( ground );

       //sun
        var distance = 5000;
        var spheregeometry = new THREE.SphereGeometry( 20, 30, 30 );
        var spherematerial =  new THREE.MeshBasicMaterial( { color: 0xf9d71c} );
        sphere = new THREE.Mesh( spheregeometry, spherematerial );
        //sphere.position.x = 3000;
				sphere.position.y = 1230;  //maximum 380
			  sphere.position.z = 3000;
        scene.add( sphere );


      }

  CreateScene();

  //lighting
  var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff,0.5);
			hemiLight.color.setHSL(0.6, 0.75, 0.5);
		//	hemiLight.groundColor.setHSL( 0.095, 0.5, 0.5);
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );

  var dirLight = new THREE.DirectionalLight(new THREE.Color(1,1,1), 0.8);
			dirLight.position.multiplyScalar( 50 );
      dirLight.castShadow = true;
      dirLight.position.y =sphere.position.y;
      dirLight.position.x = sphere.position.x;
      dirLight.position.z = sphere.position.z;
      scene.add( dirLight );
  var direcLightHelper = new THREE.DirectionalLightHelper(dirLight,50);
  scene.add(direcLightHelper);
  //shadow distance should be modify after all thing is prepared, because 
  //it has maxmum distance for shadow, like if y > 380, it wouldn't have shadow;

  //gui for control sundir and light, will changed later to make the shadow works.
    var guiControl = new function(){
      this.sunPosition = 0;
    }
    var datGUI = new dat.GUI();
    datGUI.add (guiControl, 'sunPosition', 0,300);
    render();
  function render(){
   sphere.position.y = guiControl.sunPosition*5;
   sphere.position.z = 3000 - guiControl.sunPosition*10;
   hemiLight.intensity = guiControl.sunPosition*0.005+0.5;
   dirLight.position.y =sphere.position.y;
   dirLight.position.z =sphere.position.z;
   requestAnimationFrame(render);
   renderer.render(scene,camera);
 }







  //////////////
	// CONTROLS //
	//////////////

	// move mouse and: left   click to rotate,
	//                 middle click to zoom,
	//                 right  click to pan
  // add the new control and link to the current camera to transform its position

  controls = new THREE.OrbitControls( camera, renderer.domElement );

  //final update loop
  var MyUpdateLoop = function ( )
  {
    //call the render with the scene and the camera
    renderer.render(scene,camera);

    controls.update();

    //finally perform a recoursive call to update again
    //this must be called because the mouse change the camera position
    requestAnimationFrame(MyUpdateLoop);

  };

  requestAnimationFrame(MyUpdateLoop);

  //this fucntion is called when the window is resized
  var MyResize = function ( )
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width,height);
    camera.aspect = width/height;
    camera.updateProjectionMatrix();
    renderer.render(scene,camera);
  };

  //link the resize of the window to the update of the camera
  window.addEventListener( 'resize', MyResize);
    </script>
  </body>
</html>